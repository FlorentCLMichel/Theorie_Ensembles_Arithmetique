\section{Codes Haskell, C/C++ et Rust}

\localtoc

\subsection{Écriture d'un entier naturel en base \texorpdfstring{$b$}{b}}
\label{app:Haskell_baseb}

\noindent
\textattachfile{Ensembles_Arithmétique/Code/base.hs}{\textbf{Base.hs}}
\vspace*{-1ex}
\inputminted{Haskell}{Ensembles_Arithmétique/Code/base.hs}

\subsection{Test de primalité}
\label{app:Haskell_primalité}

\noindent 
La fonction \texttt{isPrime} ci-dessous teste si un entier $p$ est un nombre premier. 
Sa complexité est $O \left( p^{1/2} \right)$.

\vspace*{1ex}

\noindent
\textattachfile{Ensembles_Arithmétique/Code/isPrime.hs}{\textbf{isPrime.hs}}
\vspace*{-1ex}
\inputminted{Haskell}{Ensembles_Arithmétique/Code/isPrime.hs}

\noindent
La fonction \texttt{findNPrimes} ci-dessous prend un entier naturel $N$ en argument et retourne la liste des $N$ premiers nombres premiers. 

\vspace*{1ex}

\noindent
\textattachfile{Ensembles_Arithmétique/Code/FindNPrimes.hs}{\textbf{FindNPrimes.hs}}
\vspace*{-1ex}
\inputminted{Haskell}{Ensembles_Arithmétique/Code/FindNPrimes.hs}

\medskip

\noindent Version C du test de primalité: 
\textattachfile{Ensembles_Arithmétique/Code/is_prime.c}{\textbf{is\_prime.c}}
\inputminted{C}{Ensembles_Arithmétique/Code/is_prime.c}

\medskip

\noindent Version Rust du test de primalité: 
\textattachfile{Ensembles_Arithmétique/Code/is_prime.rs}{\textbf{is\_prime.rs}}
{\color{white}
\inputminted{Rust}{Ensembles_Arithmétique/Code/is_prime.rs}
}

\subsection{PGCD}
\label{app:Haskell_pgcd}

\noindent 
La fonction \texttt{pgcd} ci-dessous prend comme arguments deux entiers naturels et donne leur pgcd.

\vspace*{1ex}

\noindent
\textattachfile{Ensembles_Arithmétique/Code/Base.hs}{\textbf{pgcd.hs}}
\vspace*{-1ex}
\inputminted{Haskell}{Ensembles_Arithmétique/Code/pgcd.hs}

\medskip

\noindent Version C: 
\textattachfile{Ensembles_Arithmétique/Code/pgcd.c}{\textbf{pgcd.c}}
\inputminted{C}{Ensembles_Arithmétique/Code/pgcd.c}

\medskip

\noindent Version Rust: 
\textattachfile{Ensembles_Arithmétique/Code/pgcd.rs}{\textbf{pgcd.rs}}
{\color{white}
\inputminted{Rust}{Ensembles_Arithmétique/Code/pgcd.rs}
}

\medskip

\noindent Algorithme pour trouver l'inverse d'un entier naturel $n$ modulo un autre $q$ : 
\textattachfile{Ensembles_Arithmétique/Code/inverse_mod.rs}{\textbf{inverse\_mod.rs}}
{\color{white}
\inputminted{Rust}{Ensembles_Arithmétique/Code/inverse_mod.rs}
}

\noindent L'idée est ici de calculer le pgcd $g$ de $n$ et $q$ ainsi que deux entiers $u$ et $v$ tels que $u \, n + v \, q = q$. 
Si $g = 1$, alors $u$ est l'inverse de $n$ modulo $q$. 
Sinon, $n$ n'est pas inversible modulo $q$. 
Pour ce faire, on cherche à maintenir les égalités suivantes à chaque itération : $u \, n + v \, q = a$ et $v \, n + (u - (a \div b) \, v) = b$, où le symbole $\div$ représente le quotient de la division euclidienne. 
On initialise ces quantités à $a \leftarrow n$, $b \leftarrow q$, $u \leftarrow 1$ et $v \leftarrow 0$, et utilise les propriétés suivantes : si $u \, n + v \, q = a$ et $v \, n + (u - (a \div b) \, v) ,\ q = b$, et si $a' = b$, $b' = a - (a \div b) \, b$, $u' = v$ et $v' = u - (a \div b) \, v$, alors
\begin{itemize}[nosep]
    \item $u' \, n + v' \, q = v \, n + (u - (a \div b) \, v) \, q = b = a'$,
    \item $v' \, n + (u' - (a \div b) \, v') ,\ q = (u - (a \div b) \, v) \, n + v \, q - (a \div b) \, (u - (a \div b) \, v) \, q = a - (a \div b) \, b = b'$.
\end{itemize}

\subsection{Crible d'Érastosthène}
\label{app:code_erastosthene}

\index{Erastosthene@Érastosthène}

Il s'agit d'un algorithme permettant de trouver tous les nombres premiers infèrieurs ou égaux à un entier naturel donné.

\bigskip

\noindent Version C++: 
\textattachfile{Ensembles_Arithmétique/Code/Érastosthène.cpp}{\textbf{Érastosthène.cpp}}
\inputminted{C++}{Ensembles_Arithmétique/Code/Érastosthène.cpp}

\bigskip

\noindent Version Rust\footnote{
    Cette version est sensiblement plus longue car le compilateur rustc 1.51.0, utilisé pour tester la version Rust, n'optimise pas les vecteurs de type \texttt{bool}—chaque entrée prend ainsi un octet en mémoire. 
    Nous définissons donc des fonctions auxiliaires afin de pouvoir représenter huit \texttt{bool}s pour chaque octet, afin de ne pas utiliser plus de mémoire que nécessaire.
    Le compilateur g++ 7.5.0 avec lequel la version C++ a été testée optimise les vecteurs de type \texttt{bool} pour que chaque entrée ne prenne (en moyenne et pour de grands vecteurs) qu'un bit de mémoire ; il n'est donc pas besoin, pour cette version, d'employer des fonctions auxiliaires. 
}: 
\textattachfile{Ensembles_Arithmétique/Code/Érastosthène.rs}{\textbf{Érastosthène.rs}}
{\color{white}
\inputminted{Rust}{Ensembles_Arithmétique/Code/Érastosthène.rs}
}
